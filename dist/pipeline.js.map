{"version":3,"sources":["pipeline.js"],"names":[],"mappings":"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","file":"pipeline.js","sourcesContent":["import _ from \"lodash\";\nimport {metadata} from \"aurelia-metadata\";\nimport toposort from \"toposort\";\nimport Promise from \"any-promise\";\nimport {beforeTypes,afterTypes} from \"./decorators\";\n\n/**\n* The default execute function, does nothing, serves as end of pipeline\n*/\nasync function asyncNoop() {}\n\n/**\n* Gets a component factory\n*/\nexport function getComponentFactory({ factory, container }) {\n\n  if (factory) {\n    return factory;\n  }\n  else if (container) {\n    return ComponentType => container.get(ComponentType);\n  }\n  else {\n    return ComponentType => new ComponentType();\n  }\n\n}\n\n/**\n* Helper to normalize a component spec\n*/\nexport function normalizeComponentSpec( componentSpec ) {\n\n  // expand bare constructor references into spec objects\n  let normalizedSpec = componentSpec;\n  if (_.isFunction( normalizedSpec )) {\n    normalizedSpec = {\n      type: componentSpec\n    };\n  }\n\n  // fill in defaults\n  return _.defaults( {}, normalizedSpec, {\n    key: normalizedSpec.type,\n    before: [],\n    after: [],\n    useMetadata: true\n  });\n\n}\n\n/**\n* Helper to get the dependency relationships from metadata for a type\n*/\nexport function getComponentDependencies( componentSpec ) {\n\n  // dependencies from before relationships\n  const beforeDependencies = _(componentSpec.before)\n    .concat( metadata.get( beforeTypes, componentSpec.type ) || [])\n    .flatMap( beforeType => [\n      [ beforeType, componentSpec.key ],\n      [ beforeType, componentSpec.type ]\n    ]);\n\n  // dependencies from after relationships\n  const afterDependencies = _(componentSpec.after)\n    .concat( metadata.get( afterTypes, componentSpec.type ) || [])\n    .flatMap( afterType => [\n      [ componentSpec.key, afterType ],\n      [ componentSpec.type, afterType ]\n    ]);\n\n  // return all dependencies\n  return beforeDependencies.concat(afterDependencies).value();\n}\n\n/**\n\n* The main pipeline component\n*/\nexport class Pipeline {\n\n  /**\n  * @constructor\n  * @param {object} components          Array of components\n  */\n  constructor({ components, before= asyncNoop, after = asyncNoop }) {\n\n    // store the components\n    this.components = components;\n\n    /**\n    * @method                           Uses named parameters\n    * @param {object} context           The context object on which the pipeline operates\n    * @param {object} options           The options object for this run\n    */\n    this.execute = _(components).reduceRight( ( innerExecute, component  ) => {\n\n      return async function({ context, options }) {\n\n        // call the before hook\n        await Promise.resolve( (options.before || before)({\n          component,\n          context,\n          options\n        }));\n\n        // call the component\n        await Promise.resolve( component.execute({\n          context: context,\n          options: options,\n          next: () => innerExecute({ context, options })\n        }));\n\n        // call the after hook\n        await Promise.resolve( (options.after || after)({\n          component,\n          context,\n          options\n        }));\n\n      };\n\n    }, asyncNoop );\n\n  }\n\n  /**\n  * Creates a pipeline from a set of component types using the provided container\n  * @method\n  */\n  static create({ components, factory, container, before = asyncNoop, after = asyncNoop }) {\n\n    // determine the factory function to use\n    const componentFactory = getComponentFactory({ factory, container });\n\n    // normalize component specs\n    const normalizedComponentSpecs = _.map( components, normalizeComponentSpec );\n\n    // get all dependencies (edge nodes)\n    const componentDependencies = _.flatMap( normalizedComponentSpecs, getComponentDependencies );\n\n    // get the components in sorted order -- kgw!\n    const sortedComponentSpecs = toposort.array( normalizedComponentSpecs, componentDependencies ).reverse();\n\n    // create all the component objects -- must key on type!\n    const componentInstances = _.map( sortedComponentSpecs, spec => componentFactory( spec.type ));\n\n    // create the pipeline\n    return new Pipeline({ components: componentInstances, before: before, after: after });\n\n  }\n\n}\n"],"sourceRoot":"/source/"}