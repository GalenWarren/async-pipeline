{"version":3,"sources":["pipeline.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;UAagB;UAiBA;UAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;wDA7ChB,iBAA2B,OAA3B;;;;;;;;;;;;oBAAe;;;;;;;;AAKR,WAAS,mBAAT,OAAqD;QAAtB,uBAAsB;QAAb,2BAAa;;;AAE1D,QAAI,OAAJ,EAAa;AACX,aAAO,OAAP,CADW;KAAb,MAGK,IAAI,SAAJ,EAAe;AAClB,aAAO;eAAiB,UAAU,GAAV,CAAc,aAAd;OAAjB,CADW;KAAf,MAGA;AACH,aAAO;eAAiB,IAAI,aAAJ;OAAjB,CADJ;KAHA;GALA;;;;;AAiBA,WAAS,sBAAT,CAAiC,aAAjC,EAAiD;;;AAGtD,QAAI,iBAAiB,aAAjB,CAHkD;AAItD,QAAI,iBAAE,UAAF,CAAc,cAAd,CAAJ,EAAoC;AAClC,uBAAiB;AACf,cAAM,aAAN;OADF,CADkC;KAApC;;;AAJsD,WAW/C,iBAAE,QAAF,CAAY,EAAZ,EAAgB,cAAhB,EAAgC;AACrC,WAAK,eAAe,IAAf;AACL,gBAAU,EAAV;AACA,eAAS,EAAT;AACA,mBAAa,IAAb;KAJK,CAAP,CAXsD;GAAjD;;;;;AAuBA,WAAS,wBAAT,CAAmC,aAAnC,EAAmD;AACxD,WAAO,EAAP,CADwD;GAAnD;;;;;;;MAQM;;;;;;;AAMX,aANW,QAMX,QAA4B;UAAd,8BAAc;;4BANjB,UAMiB;;;AAG1B,WAAK,UAAL,GAAkB,UAAlB;;;;;;AAH0B,UAS1B,CAAK,OAAL,GAAe,sBAAE,UAAF,EAAc,WAAd,CAA2B,UAAE,YAAF,EAAgB,SAAhB,EAAgC;;AAExE,eAAO;iBAAW,qBAAQ,OAAR,CAAiB,UAAU,OAAV,CAAmB,OAAnB,EAA4B;mBAAM,aAAc,OAAd;WAAN,CAA7C;SAAX,CAFiE;OAAhC,EAIvC,UAJY,CAAf,CAT0B;KAA5B;;;;;;;;iBANW;;oCA2BuC;YAAlC,8BAAkC;YAAtB,wBAAsB;YAAb,4BAAa;;;;AAGhD,YAAM,mBAAmB,oBAAoB,EAAE,gBAAF,EAAW,oBAAX,EAApB,CAAnB;;;AAH0C,YAM1C,kBAAkB,iBAAE,GAAF,CAAO,UAAP,EAAmB,sBAAnB,CAAlB;;;AAN0C,YAS1C,eAAe,iBAAE,OAAF,CAAW,eAAX,EAA4B,wBAA5B,CAAf;;;AAT0C,YAY1C,cAAc,mBAAS,KAAT,CAAgB,eAAhB,EAAiC,YAAjC,EAAgD,OAAhD,EAAd;;;AAZ0C,YAe1C,qBAAqB,iBAAE,GAAF,CAAO,WAAP,EAAoB;iBAAQ,iBAAkB,KAAK,IAAL;SAA1B,CAAzC;;;AAf0C,eAkBzC,IAAI,QAAJ,CAAa,EAAE,YAAY,kBAAZ,EAAf,CAAP,CAlBgD;;;;WA3BvC","file":"pipeline.js","sourcesContent":["import _ from \"lodash\";\nimport toposort from \"toposort\";\nimport Promise from \"any-promise\";\nimport {precedesTypes,followsTypes} from \"./decorators\";\n\n/**\n* The default execute function, does nothing, serves as end of pipeline\n*/\nasync function terminator( context ) {}\n\n/**\n* Gets a component factory\n*/\nexport function getComponentFactory({ factory, container }) {\n\n  if (factory) {\n    return factory;\n  }\n  else if (container) {\n    return ComponentType => container.get(ComponentType);\n  }\n  else {\n    return ComponentType => new ComponentType();\n  }\n\n}\n\n/**\n* Helper to normalize a component spec\n*/\nexport function normalizeComponentSpec( componentSpec ) {\n\n  // expand bare constructor references into spec objects\n  let normalizedSpec = componentSpec;\n  if (_.isFunction( normalizedSpec )) {\n    normalizedSpec = {\n      type: componentSpec\n    };\n  }\n\n  // fill in defaults\n  return _.defaults( {}, normalizedSpec, {\n    key: normalizedSpec.type,\n    precedes: [],\n    follows: [],\n    useMetadata: true\n  });\n\n}\n\n/**\n* Helper to get the dependency relationships from metadata for a type\n*/\nexport function getComponentDependencies( componentSpec ) {\n  return [];\n}\n\n/**\n\n* The main pipeline component\n*/\nexport class Pipeline {\n\n  /**\n  * @constructor\n  * @param {object} components          Array of components\n  */\n  constructor({ components }) {\n\n    // store the components\n    this.components = components;\n\n    /**\n    * @method\n    * @param {object} context           The context object on which the pipeline operates\n    */\n    this.execute = _(components).reduceRight( ( innerExecute, component  ) => {\n\n      return context => Promise.resolve( component.execute( context, () => innerExecute( context )));\n\n    }, terminator );\n\n  }\n\n  /**\n  * Creates a pipeline from a set of component types using the provided container\n  * @method\n  */\n  static create({ components, factory, container }) {\n\n    // determine the factory function to use\n    const componentFactory = getComponentFactory({ factory, container });\n\n    // normalize component specs\n    const normalizedSpecs = _.map( components, normalizeComponentSpec );\n\n    // get all dependencies (edge nodes)\n    const dependencies = _.flatMap( normalizedSpecs, getComponentDependencies );\n\n    // get the components in sorted order -- kgw!\n    const sortedSpecs = toposort.array( normalizedSpecs, dependencies ).reverse();\n\n    // create all the component objects -- must key on type!\n    const componentInstances = _.map( sortedSpecs, spec => componentFactory( spec.type ));\n\n    // create the pipeline\n    return new Pipeline({ components: componentInstances });\n\n  }\n\n}\n"],"sourceRoot":"/source/"}